{"pages":[],"posts":[{"title":"javascript(es5&#x2F;es6)","text":"javascript(es5/es6)函数arguments log函数因为console.log():也是通过()来调用的,所以log也是一个函数.log函数的特点.可以接受一个或多个参数. 为什么log函数可以接受一个或多个参数.内部实现原理就用到了arguments. arguments的作用保存所有传递函数的实参 注意点:每个函数中都有一个arguments的东东.arguments其实是一个伪数组 数组 array数组是引用数据类型.(对象类型) 以前number/string/Boolean,是基础数据类型 let 变量名称 = new Array(size); 如何存储数据?变量名称[索引号] = 需要存储的数据;arr[0] = ‘’数据 ‘; 如何从数组中获取存储的数据;变量名称[索引号];arr[0]; 注意点:1.和其他编程语言不同,如果数组对应的索引中没有存储数据,默认存储undefined, 其他编程语言中默认保存的是垃圾数据或者0. 2.和其他编程语言不同,JavaScript中访问了数组不存在的索引不会报错,会返回undefined. 其他编程语言一旦超出索引范围就会报错或者返回脏数据 3.和其他编程语言不同,当JavaScript中数组的存储空间不够时,数组会自动扩容. 其他编程语言中数组的大小都是固定的 indexOf(“@”) 从前往后判断是否有”@”， 如果没有则输出-1,只要这个字符出现在输入字符串中，不管具体在任何位置，都会返回它索引中的位置，换句话说某个大于-1的数 lastindexOf() 从后往前找 … 扩展运算符注意点:1.扩展运算符在解构赋值(等号的左边)表示将剩余的数据打包成一个新的数组.扩展运算符在解构赋值(等号的右边,)那么表示将数组中所有的数据解开,放到所在的位置 如何对数组内容进行反转 ?let arr = [1, 2, 3, 4, 5]; let res = arr.reverse(); console.log(res);反转之后变成 5,4,3,2,1;注意点: 会修改原有的数组;如何截取数组中指定范围内容? 123let res = arr.slice(2,5); console.log(res); console.log(arr); slice方法就是包头不包尾(包含起始位置,不包含结束位置); 如何查找元素在数组中的位置? 123let res = arr.indexOf(3); console.log(res); console.log(arr); indexOf如果找到了指定的位置,就会返回元素的对应位置.indexOf如果没有找到指定的元素,就会返回-1.注意点: indexOf方法默认是从左至右的查找,一旦找到就会立即停止查找.参数1:需要查找的元素.参数2:从什么位置开始查找.lastindexOf()方法从右至左的查找,一旦找到就会立即停止查找 数组fill方法数组的fill方法的作用: 设置数组中所有元素的值为指定的数据; split 方法分解数组 方法// 队列形式push() // 添加数组到第一个pop() // 删除数组最后一个unshift() // 添加第一个shift() //删除第一个slice(开始位置，结束位置) //提取数组，原数组不变splice(索英值，删除的数量，添加的内容) //可以删除也可以添加，会改变原数组将伪数组转化为真数组array.prototype.slice.call(array)或者[].slice.call(array)或者array.from(array)cancat() //连接多个数组转化为新数组join() //将每一个字符串进行拼接 sort方法123456789101112var arr = [1,44,3,122,8,678]var fn = function (a, b){ if(a&gt;b){ return 1 }else{ return -1 }}var newarr = arr.sort(fn)console.log(newarr) forEachmap()1234hotmodel.map(function (item, index) { return item }) //需要返回值循环之后会生成一个新的数组 filter()12345678var newarr = hotmodeal.filter(function (item,i,arr){ if(parseFloat(item.minRent)&gt;100){ return true; }else{ return false; } }) 过滤 every()判断内容是否满足某个条件，如果一个不满足，就会返回false some()判断内容是否满足某个条件，只要有一个满足，就会返回true reduce123hotmodel.reduce(function (value,item,i,arr) { return value + parseFloat(item.minRent)}, 0) // 初始值为0 计算所有项目总价 需要对数组的每个内容进行遍历，最终输出一个总结果的话，需要用reduce find()array.from()循环语句while123456while 特点while(条件表达式){ 条件满足执行的语句;}大括号中的代码有可能会被执行很多次. 执行流程:1.首先会判断条件表达式 是否为真,如果为真就执行后面 {} 的代码.2.执行完后面 {} 的代码,会再次判断表达式是否为真.3.如果条件表达式还为真,那么会再次执行后面 {}中的代码.4.直到条件表达式不为真为止. 书写循环结构的代码: 1.不管三七二十一先写上循环结构的代码 2.将需要重复执行的代码拷贝到 {} 中 3.再()中指定循环结束的条件. 只有条件表达式为真 ,才会执行循环体. do while123do{ 需要重复执行的代码;}while(条件表达式); 无论条件表达式是否为真,循环体都会被执行一次. 在企业开发中大部分情况下while 循环和do while循环都可以互换的.如果循环体中的代码无论如何都需要先执行一次,那么建议使用do while循环,其他情况都使用while for循环1234567891011121314151617for循环格式1.初始化表达式.let num = 1;2.条件表达式.while(num &lt;= 1){ console.log(&quot;发射子弹&quot; + num);3.循环后增量表达式.num++;}for(let num = 1; num &lt;= 1;num++;){ console.log(&quot;发射子弹&quot; + num);}执行流程 1 2/5/8 4/7/10for(初始化表达式;条件表达式:循环后增量表达式){ 3/6/9 需要重复执行的代码;} while循环不能省略条件表达式,否则会报错.而for循环是可以省略表达式的,默认就是真. for in continue 关键字只能用于循环结构, 作用: 跳过本次循环,进行下一次循环. 注意点:和break关键字一样,后面不能编写其他代码,因为执行不到. 循环嵌套外循环控制行数,内循环控制列数.规律:如果剑尖朝下,那么只需要修改内循环的初始表达式,为外循环初始表式变量即可 如果剑尖朝上,那么只需要修改内循环的条件表达式,为外循环初始表式变量即可 if 条件语句if(条件表达式A){条件满足A时执行} 继续执行if(条件表达式A){条件满足A时执行}else{条件不满足时}if(条件表达式A){条件满足A时执行}else{条件不满足时}else if(条件表达式B){条件满足B时执行}else{前面所有条件不满足}注意点1.对于非布尔类型的数据,会先转换成布尔类型再判断.2.对于==/===判断,将常量写在前面.let num = 10; //if(num = 5)if(5 == num){console.log(A);}console.log(B); 3.if/else if/else后面的大括号都可以省略,但是省略之后只有紧随其后的语句受到控制. if(flase) console.log(A); console.log(B);//不会受到控制;4.在JavaScript中分号也是一条语句,(空语句). 5.if选择结构可以嵌套使用. 6.当if选择省略大括号的时候,else if/else会自动和距离最近没有被使用的if匹配. switch 语句switch 特点123456789101112switch格式switch(表达式){ case 表达式A: 语句A: break; case 表达式B: 语句B: break; default: 前面所有case都不匹配执行的代码; break;} 1.会从上至下的一次判断每一个case是否和()中表达式的结果相等.如果相等就执行对应case后面的代码,如果前面所有的case都不匹配,那么就会执行default后面的代码.并且所有的case代码和default只有一个会被执行,并且只会被执行一次. 注意点 case判断的是===,而不是==.2.()可以是常量,也可以是变量,还可以是表达式.3.case后面也可以是常量,也可以是变量,还可以是表达式.4.break的作用是立即结束整个switch语句.在switch语句中一旦case或者default被匹配,那么其他的case和default都会失效.5.default不一定要写到最后.6.和if/else中的else一样,default也可以省略. 注意点: 在企业开发中,如果是对区间进行判断,那么建议使用if. 如果是对几个固定值判断,建议使用switch. 能用if就用if break 关键字break语句用于switch语句和循环结构中,立即结束当前的switch语句,或当前的循环, 注意点: 1.就是break语句,后面不能编写任何语句,因为永远不会执行到. 2.如果在循环嵌套的结构中,break结束的是当前所在的循环. 运算符123456789### +### -### *### /### % 自增运算符就是 ++相当于 +1相当于+=1自增自减写在变量前面和后面的区别?写在变量前面表示:先自增或者自减,然后再参与其它的运算.写在变量后面表示:先参与其它的运算,然后再自增或自减. 自减运算符就是 –相当于 -1相当于-=1 ==只会判断取值是否相等,不会判断数据类型是否相等 !=只会判断取值 ===不仅会判断取值是否相等,而且还会判断数据类型是否相等.只有取值和数据类型都相等,才会返回true !==会同时判断取值和数据类型 关系运算符 从左至右 关系运算符的结合性和优先性 let num = 10 &gt; 5 &gt; 2;// let num = true &gt; 3 1 &gt; 3;注意点:正是因为关系运算符是左结合性,所以不能用关系运算符来判断区间. 关系运算符中 &gt; &lt; &gt;= &lt;= 的优先级高于 == != === !== 逻辑运算符1.在逻辑运算符中,如果不是布尔类型,那么会先转换为布尔类型再参与其它运算.2.如果参与运算的不是布尔类型,返回值有一个特点格式:条件A &amp;&amp; 条件B如果条件A不成立,那么就返回条件A如果条件A成立,无论条件B是否成立,都会返回条件B &amp;&amp; 逻辑与 优先级高 由于与运算规则是一假则假,所以只要条件A是假,条件B就不会运算 . 一假则假 || 逻辑或 由于或运算规则是一真则真,所以只要条件A是真,条件B就不会运算. 一真则真 ! 条件表达式 真变假 假变真 , 逗号运算符逗号运算符是所有运算符中最低的.逗号运算符的运算结果就是最后一个表达式的运算结果.let num = (1+2),( 2 + 2),( 3+3); 三目运算符条件表达式? 结果A : 结果B ; 当条件为真就会返回结果A当条件为假就会返回结果B 数据类型基本数据类型 number 数值类型 在JavaScript中无论是整数还是小数都是属于数值类型 利用typeof检测123这个常量是属于哪一种类型，并且将结果保存到res这个变量中。 let res = typeof 123； consloe.log（res）； number转换字符串 对于number类型和boolean类型转换可以通过变量名称 .tostring（）的方式来转换 let value = 123；//以下代码的含义：将value变量中存储的数据拷贝一份，然后将拷贝的数据转换为字符串之后返回let str = value.tostring（）； 或者let str = value + ‘’；或者let str = 123 + ‘’；其实底层的本质就是调用了String()函数； //注意点：变量名称 .tostring是对拷贝的 数据进行转换，所以不会影响到原有的数据 //注意点：不能使用常量直接调用 .tostring方法，因为常量是不能改变呢。 在谷歌浏览器中控制台打印的数值是蓝色 字符串是黑色 3.可以通过 + - 符号来转换但会改变数字的正负性 4.可以通过parseInt(需要转换的字符串) /parseFloat(需要转换的字符串) 注意:parseInt/parseFloat都会从坐至右的提取数值,一旦遇到非数值就会立即停止. 停止的时候如果还没有遇到数值,就会返回NaN. parseInt/parseFloat都会将传入的数据当做字符串来处理 ​ number转换Boolean 通过Boolean()转换 只有数值为0才会转换为false,其他的都是true.如果是NaN也会转换为false string 字符串类型 字符串转换number 1.通过Number（）来转换 let str = “123”；let num = number（str）； //注意点：如果字符串中没有数据，那么转换的是0。如果字符串中的数据不仅仅是数值，那么转换的结果是NaN 字符串转换Boolean Boolean()只要字符串里面有值,就是true.没值就是false. Boolean 布尔值类型 truefalse 布尔值转换number 如果布尔值类型是true,那么转换后的结果为1 如果布尔值类型是false,那么转换后的结果为0 undefined 未定义类型 undefined转换为字符串 0 可以通过String（）（变量or常量）：转换字符串 let value = undefined；//以下代码的含义：根据传入的数据重新生成一个字符串let str = String（value）； //注意点：变量名称 .tostring（）的方式前面不能是常量，因为常量不能被改变。 String（常量or变量），因为是根据传入的值重新生成的一个新值，并不是修改原有的值 - undefined转换number NaN 转换之后为NaN undefined转换为Boolean Boolean()undefined会转换为false null 空类型 null转换字符串 为false 空字符串/0/NaN/undefined/null会转换为false其他都是true null转换为number 0 转换之后为0 引用数据类型 object 对象类型 变量什么是变量？变量可以表示一些可以被修改的数据 如何修改变量的值？在JavaScript中想要修改变量中存储的数据，只需要再次给变量直接赋值即可。 在JavaScript中 第一次给变量赋值，我们称之为“变量初始化” var可以重复声明 letes6 let num = 123；let num = 444；不能重复声明 常量什么是常量？常量表示固定不变的数据。 整型常量什么是整型常量？整型常量其实就是正数,在JavaScript里面随便写一个整数就是整型常量. 6661922 实型常量什么是实型常量？实型常量其实就是小数,在JavaScript里面随便写一个小数就是实型常量. 6.661.92.2 字符串常量什么是字符串常量？字符串常量其实就是用双引号或者单引号括起来,就是字符串 “6.66”’1.9‘“adad” 布尔常量什么是布尔常量？布尔常量其实就是真或者假。在JavaScript里面用true或者false表示。 自定义常量什么是自定义常量？ 自定义常量在es6中新增的 const 常量名称 = 常量取值； const num = 666； 输出方式弹窗输出 prompt 输入提示框 confirm 有确定，取消按钮 网页输出 document.write 界面输出 控制台输出 console.log 普通输出 consloe.warn 警告输出 console.error 错误输出 递归1.找规律2.找出口 n的阶乘function mul(n){ if(n == 1 || n == 0){ return 1 } return n * mul(n - 1)} 斐波那契数列// fb(n) == fb(n - 1) + fb(n - 2)function fb(n) { if(n == 1 || n == 2){ return 1; } return fb(n - 1) + fb(n - 2)} 单线程、解释型语言函数声明整体提升变量 声明提升预编译imply global // 暗示全局变量 thisthis的指向根据函数的调用方式不同，this会指向不同对象。1.以函数的方式调用，this的指向永远是window，比如fun(),,, 其实就是window.fun()2.以方法的形式调用是，this的指向就是那个方法。3.以构造函数的形式调用时，this的指向就是新创建的对象。4.使用call和apply调用时，this是指定的那个对象。 call、apply、bind修改this指向 student.lick.call(teacher,’1’,’2’) //参数 student.like.apply(teacher,[‘1’,’2’]) //数组 function (){name: ‘333’}.bind(student) 原型对象(链)原型对象也是对象，所以他也有原型，当我们使用或访问一个方法的时候 它会在对象自身中寻找，如果有就直接使用；如果没有就会去原型对象去寻找，如果找到直接使用；如果没有就会去原型的原型去寻找，直到找到object对象的原型如果在object中还是没有的话，则返回null 作用当你的代码每次重新创建的话内存占的比较多，就可以使用原型prototype 1.创建构造函数2.创建原型对象3.设置构造函数原型对象的prototype 注：将这一类型用到的方法都进行封装，封装到对象，并且将这个对象给到构造函数的prototype属性 12345678910var teacherProtype = { like:function () { console.log(this.name + '喜欢' + this.age) }, teach:function () { console.log(this.name + '学生' + this.age) }}Teacher.prototype = teacherProtype; __proto__和prototype指的都是原型对象创建对象方式字面量工厂模式12345678910function Student(name, age) { var student = { name:name, age:age } return Student}var s1 = Student('小明'，'13')var s2 = Student('小3'，23') 工厂模式12345678910function Student(name, age) { var student = { name:name, age:age } return Student}var s1 = Student('小明'，'13')var s2 = Student('小3'，23') 构造函数12345678function Teacher(name, age, likename) { this.name = name, this.age = age, this.like = function (){ console.log(this.name + '喜欢' + likename) ]}var t1 = new Teacher('小黑'，16, '篮球') class类(es6)1234567891011121314class car{ constructor(name,color){ this.name = name, this.age = age /*this.like = function () { console.log(this.name + '喜欢' + this.color) }*/ } like() { //自动设置原型对象 console.log(this.name + '喜欢' + this.color) }}var c1 = new car('小轿车', '白色') 类(实例)使用同一构造函数创建的对象，我们称为一类对象，也将一个构造函数称之为类 通过构造函数创建的类，我们称之为该类为实例 可以检查这个实例是否是这个构造函数构造出来的对象 instanceof 构造函数 RegExp对象RegExp对象表示正则表达式，他是对字符串执行匹配的强大工具 表达式","link":"/2021/08/26/javascript-es5-es6/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"}],"categories":[]}